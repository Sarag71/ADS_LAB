//sarah_22011324_lab 8 binary search tree

#include <iostream>
using namespace std;

// Node structure for the binary search tree
class Node {
public:
    int value;
    Node* left;
    Node* right;

    Node(int v) : value(v), left(nullptr), right(nullptr) {}
};

// Binary search tree class
class Tree {
public:
    Node* root;

    Tree() : root(nullptr) {}

    void add_root(int value) {
        root = new Node(value);
    }

    void add_left(Node* parent, int value) {
        if (parent)
            parent->left = new Node(value);
    }

    void add_right(Node* parent, int value) {
        if (parent)
            parent->right = new Node(value);
    }

    void display_structure() {
        if (!root) return;

        cout << "Root: " << root->value << endl;

        if (root->left) {
            cout << "Left child of root: " << root->left->value << endl;

            if (root->left->left)
                cout << "Left child of " << root->left->value << ": " << root->left->left->value << endl;

            if (root->left->right)
                cout << "Right child of " << root->left->value << ": " << root->left->right->value << endl;
        }

        if (root->right) {
            cout << "Right child of root: " << root->right->value << endl;

            if (root->right->left)
                cout << "Left child of " << root->right->value << ": " << root->right->left->value << endl;

            if (root->right->right)
                cout << "Right child of " << root->right->value << ": " << root->right->right->value << endl;
        }
    }

    // Binary Search Method (Divide and Search)
    Node* search(Node* current, int target) {
        if (!current)
            return nullptr;

        if (target == current->value)
            return current;
        else if (target < current->value)
            return search(current->left, target);
        else
            return search(current->right, target);
    }
};

int main() {
    Tree tree;

    // Manually building BST (must follow BST rules for binary search to work)
    tree.add_root(50);
    tree.add_left(tree.root, 30);
    tree.add_right(tree.root, 70);
    tree.add_left(tree.root->left, 20);
    tree.add_right(tree.root->left, 40);
    tree.add_left(tree.root->right, 60);
    tree.add_right(tree.root->right, 80);

    tree.display_structure();

    // Searching for a value
    int target = 60;
    Node* found = tree.search(tree.root, target);

    if (found)
        cout << "\nValue " << target << " found in the tree." << endl;
    else
        cout << "\nValue " << target << " not found in the tree." << endl;

    return 0;
}
